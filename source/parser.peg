/*
 * Classic example grammar, which recognizes simple arithmetic expressions like
 * "2*(3+4)". The parser generated from this grammar then computes their value.
 */
{
	var test = require("../source/config");
}

start = extcondition / conditions

extcondition
	= left:conditions space "or" space right:extcondition { return +(left || right); }
	/ left:conditions space "||" space right:extcondition { return +(left || right); }
	/ left:conditions space "and" space right:extcondition { return +(left && right); }
	/ left:conditions space "&&" space right:extcondition { return +(left && right); }
	/ space "not" space right:conditions { return +(!right); }
	/ conditions

conditions
	= left:actions space "==" space right:actions { return +(left == right); }
	/ left:actions space "!=" space right:actions { return +(left != right) }
	/ left:actions space ">=" space right:actions { return +(left >= right); }
	/ left:actions space "<=" space right:actions { return +(left <= right); }
	/ left:actions space ">" space right:actions { return +(left > right); }
	/ left:actions space "<" space right:actions { return +(left < right); }
	/ actions

actions	= left:primary right:(subsubstriction / subadditive)+ {
		right.unshift(left);
		left = right.reduce(function(v,c){return v+c});
		return left;
	}
	/ primary

subadditive = space "+" space right:primary {return +right;}
subsubstriction = space "-" space right:primary {return -right;}

primary = left:primaryDigits right:(subdivision / submultiply)+ {
		right.unshift(left);
		left = right.reduce(function(v,c){return v*c});
		return left;
	}
	/ rand
	/ primaryDigits
	/ stringRules

subdivision	= space "/" space right:primaryDigits { return 1/right; }
submultiply	= space "*" space right:primaryDigits { return right; }

primaryDigits
	= s:specialstr ".hex" { return "0x" + s; }
	/ s:specialstr space "." space right:specialstr ".length" { return (s+right).length; }
	/ s:specialstr ".length" { return s.length; }
	/ left:digits space "<<" space right:primary { return left << right; }
	/ left:digits space ">>" space right:primary { return left >> right; }
	/ left:digits space "&" space right:digits { return left & right; }
	/ left:digits space "|" space right:digits { return left | right; }
	/ left:digits space "^" space right:primary { return left ^ right; }
	/ left:digits space "%" space right:primary { return left % right; }
	/ digits

digits
	= hex
	/ "-"right:(integer / integerVariables) { return 0 - right; }
	/ integer
	/ variables

substr = space "." space right:strings { return right; }
stringRules
	= left:strings right:substr* { return left + right.join(""); }
	/ strings

strings
	= s:specialstr "[" start:integer ":" stop:integer "]" { return s.substring(start, stop); }
	/ s:specialstr "[:" stop:integer "]" { return s.substring(0, stop);	}
	/ s:specialstr "[" start:integer ":]" { return s.substring(start, s.length); }
	/ specialstr

specialstr = left:str* { return left.join(""); } / str
rand = "rand(" max:integer ")" {
	if(max <= 1){
		return 0;
	}
	
	return Math.floor(Math.random() * (max - 1));
}
str "string" = "'" s:[a-zA-Z0-9 ]* "'" { return s.join(""); }
hex "hex" = "0x" string:[a-zA-Z0-9]+ { return "0x" + string.join(""); }
integer "integer" = digits:[0-9]+ { return parseInt(digits.join(""), 10); }
space "space" = sps:[ ]* { return sps; }

variables
	= integerVariables
	/ variable:"ip" { return test.ip; }
	/ variable:"sn" { return test.sn; }
	/ variable:"mac" { return test.mac; }
	/ variable:"model" { return test.model; }

integerVariables
	= variable:"tasks" { return test.tasks; }
	/ variable:"zip" { return test.zip; }
	/ variable:"node" { return test.node; }