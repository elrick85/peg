/*
 * Classic example grammar, which recognizes simple arithmetic expressions like
 * "2*(3+4)". The parser generated from this grammar then computes their value.
 */
{
	var test = require("../source/config");
	var utils = require("../helpers/utils");
}

start = extcondition / main

main = conditions / actions

extcondition
	= left:conditions space "or" space right:extcondition { return +(left || right); }
	/ left:conditions space "||" space right:extcondition { return +(left || right); }
    / left:conditions space "and" space right:extcondition { return +(left && right); }
    / left:conditions space "&&" space right:extcondition { return +(left && right); }
    / space "not" space right:conditions { return +(!right); }
    / conditions

conditions
	= left:actions space "==" space right:actions { return +(left == right); }
	/ left:actions space "!=" space right:actions { return +(left != right) }
	/ left:actions space ">=" space right:actions { return +(left >= right); }
	/ left:actions space "<=" space right:actions { return +(left <= right); }
	/ left:actions space ">" space right:actions { return +(left > right); }
	/ left:actions space "<" space right:actions { return +(left < right); }

actions
	= left:primary space "+" space right:actions { return left + right;	}
    / left:primary space "-" space right:actions { return left - right;	}
    / primary

primary	= hex / digitRules / stringRules

digitRules
	= division
	/ left:digits space "*" space right:digits { return left*right; }
	/ digits

subdivision
	= space "/" space right:integer { return right; }
division
	=  left:integer right:subdivision+ {
		right.unshift(left);
		return right.reduce(function(v,c){ return v/c; });
	}

stringRules
	= s:strings ".length" { return s.length; }
	/ s:strings ".hex" { return "0x" + s; }
	/ concatStr
	/ strings

concatStr
 	= left:strings space "." space right:concatStr { return left + right; }
	/ strings

digits
	= rand
    / left:integer space "<<" space right:primary { return left << right; }
    / left:integer space ">>" space right:primary { return left >> right; }
    / left:integer space "&" space right:integer { return left & right; }
    / left:integer space "|" space right:integer { return left | right; }
    / left:integer space "^" space right:primary { return left ^ right; }
    / left:integer space "%" space right:primary { return left % right; }
    / "-"right:integer { return 0 - right; }
    / integer
    / variables

strings
	= s:specialstr "[" start:integer ":" stop:integer "]" { return s.substring(start, stop); }
	/ s:specialstr "[:" stop:integer "]" { return s.substring(0, stop);	}
	/ s:specialstr "[" start:integer ":]" { return s.substring(start, s.length); }
	/ specialstr

specialstr = left:str* { return left.join(""); } / str
rand "random" = "rand(" space max:integer space ")" space { return utils.rand(0, max-1); }
str "string" = "'" s:[a-zA-Z0-9\" ]* "'" { return s.join(""); }
hex "hex" = "0x" string:[a-zA-Z0-9]+ { return "0x" + string.join(""); }
integer "integer" = digits:[0-9]+ { return parseInt(digits.join(""), 10); }
space "space" = sps:[ ]* { return sps; }

variables
	= variable:"tasks" { return test.tasks; }
	/ variable:"ip" { return test.ip; }
	/ variable:"zip" { return test.zip; }
	/ variable:"node" { return test.node; }
	/ variable:"sn" { return test.sn; }
	/ variable:"mac" { return test.mac; }
	/ variable:"model" { return test.model; }