/*
 * Classic example grammar, which recognizes simple arithmetic expressions like
 * "2*(3+4)". The parser generated from this grammar then computes their value.
 */
{
	var test = require("../source/config");
}

start = extcondition / main
main = conditions / actions

extcondition
	= left:conditions space "or" space right:extcondition { return +(left || right); }
	/ left:conditions space "||" space right:extcondition { return +(left || right); }
    / left:conditions space "and" space right:extcondition { return +(left && right); }
    / left:conditions space "&&" space right:extcondition { return +(left && right); }
    / space "not" space right:conditions { return +(!right); }
    / conditions

conditions
	= left:actions space "==" space right:actions { return +(left == right); }
	/ left:actions space "!=" space right:actions { return +(left != right) }
	/ left:actions space ">=" space right:actions { return +(left >= right); }
	/ left:actions space "<=" space right:actions { return +(left <= right); }
	/ left:actions space ">" space right:actions { return +(left > right); }
	/ left:actions space "<" space right:actions { return +(left < right); }

actions
	= additive
    / primary

primary	= hex / digitRules / stringRules

digitRules = multiplicative / primaryDigits

additive
	= left:primary right:(subsubstriction / subadditive)+ {
		right.unshift(left);
		left = right.reduce(function(v,c){return v+c});
		return left;
	}

multiplicative
	= left:primaryDigits right:(subdivision / submultiply)+ {
		right.unshift(left);
		left = right.reduce(function(v,c){return v*c});
		return left;
	}

subdivision	= space "/" space right:primaryDigits { return 1/right; }
submultiply	= space "*" space right:primaryDigits { return right; }
subadditive = space "+" space right:primary {return +right;}
subsubstriction = space "-" space right:primary {return -right;}

stringRules
	= s:strings ".length" { return s.length; }
	/ s:strings ".hex" { return "0x" + s; }
	/ concatStr
	/ strings

concatStr
 	= left:strings space "." space right:concatStr { return left + right; }
	/ strings

primaryDigits
	= rand
    / left:digits space "<<" space right:primary { return left << right; }
    / left:digits space ">>" space right:primary { return left >> right; }
    / left:digits space "&" space right:digits { return left & right; }
    / left:digits space "|" space right:digits { return left | right; }
    / left:digits space "^" space right:primary { return left ^ right; }
    / left:digits space "%" space right:primary { return left % right; }
    / digits

digits
	= hex
	/ "-"right:(integer / integerVariables) { return 0 - right; }
	/ integer
	/ variables

strings
	= s:specialstr "[" start:integer ":" stop:integer "]" { return s.substring(start, stop); }
	/ s:specialstr "[:" stop:integer "]" { return s.substring(0, stop);	}
	/ s:specialstr "[" start:integer ":]" { return s.substring(start, s.length); }
	/ specialstr

specialstr = left:str* { return left.join(""); } / str
rand "random" = "rand(" space max:integer space ")" space {
	return  Math.floor(Math.random() * max - 1);
}
str "string" = "'" s:[a-zA-Z0-9\" ]* "'" { return s.join(""); }
hex "hex" = "0x" string:[a-zA-Z0-9]+ { return "0x" + string.join(""); }
integer "integer" = digits:[0-9]+ { return parseInt(digits.join(""), 10); }
space "space" = sps:[ ]* { return sps; }

variables
	= integerVariables
	/ variable:"ip" { return test.ip; }
	/ variable:"sn" { return test.sn; }
	/ variable:"mac" { return test.mac; }
	/ variable:"model" { return test.model; }

integerVariables
	= variable:"tasks" { return test.tasks; }
	/ variable:"zip" { return test.zip; }
	/ variable:"node" { return test.node; }